---
layout: post
title: Java 中 JVM 的原理（下）
categories: Java
description: Java虚拟机原理：垃圾收集器与内存分配策略
keywords: Java, JVM, Java虚拟机, 垃圾收集器, GC机制
---

上一篇文章我们对JVM有了一个粗略地认识，这一篇我们就讲一讲垃圾收集器和内存分配策略。

### 如何判断对象已死

垃圾收集器在对堆进行回收前，首先要确定对象中哪些还存活着，哪些已经死去。具体采用以下算法：

- 引用计数算法：给每个对象中添加一个引用计数器，当引用它时，计数器值就加1；当引用失效时，计数器值就减1。任何时刻计数器为0的对象就是不可能再被使用的。引用计数算法实现简单，判定效率也很高，大部分情况下它都是不错的算法。Java虚拟机没有选用引用计数算法来管理内存，主要原因是很难解决对象之间**相互循环引用**的问题。
- 可达性分析算法：通过一系列的称为“GC Roots”的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链，当从GC Roots 到这个对象不可达时，则证明此对象是不可用。

即使在可达性分析算法中不可达的对象，也并非非死不可。对象死亡至少要经过两次标记过程：如果对象在可达性分析后发现不可达，那它会被第一次标记并且进行筛选，筛选条件是对象是否有必要执行`finalize()`方法。当对象没有覆盖`fnalize()`方法，或者`finalize()`方法已被虚拟机调用过，都视为没有必要执行。

如果对象被判定为有必要执行`finalize()`方法，那对象将会被放置在名为F-Queue的队列中，井在稍后由一条由虚拟机自动建立的、低优先级的Finalizer线程执行（虚拟机会触发方法，但不承诺等待它运行结束）。`finalize()`方法是对象逃脱死亡的最后机会，稍后GC将对F-Queue中的对象进行第二次小规模标记，如果对象还没逃脱，就可以回收了。 

### Java引用

Java将引用分为强引用、软引用、弱引用、虚引用，它们的引用强度依次逐渐减弱。

- 强引用：类似`Object obj=new Object()`，只要强引用还在，垃圾收集器永远不会回收被引用的对象。
- 软引用：有用但非必需的对象。系统将发生内存溢出异常前，会把这些对象列进垃圾回收范围中进行第二次回收。如果还是没有足够内存，才抛出内存谧出异常。Soft Reference类可实现软引用。
- 弱引用：描述非必需对象。被弱引用关联的对象只能生存到下一次垃圾收集发生之前。当垃圾收集器工作肘，无论内存是否足够，都会回收掉只被弱引用关联的对象。WeakReference类可实现弱引用。
- 虚引用：最弱的引用关系。一个对象是否有虚引用，完全不影响其生存时间，也无法通过虚引用取得对象实例。为对象设置虚引用关联的唯一目的就是希望对象被回收时收到系统通知。PhantomReference类可实现虚引用。

### 回收方法区

方法区（HotSpot虚拟机中的永久代 ）垃圾收集主要回收两部分内容：废弃常量和无用类。无用类需满足3 个条件：

- 该类所有的实例都已被回收，即Java堆中不存在该类的任何实例
- 加载该类的ClassLoader已经被回收
- 该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法

虚拟机可对满足上述3 个条件的无用类进行回收，但并不一定进行回收。

### 内存分配与回收策略

- 对象优先在Eden（新生代）分配：大多数情况下，对象在新生代Eden区分配。当Eden区没有足够空间进行分配时，虚拟机将发起一次Minor GC
- 大对象直接进入老年代：虚拟机提供了参数：-XX:PretenureSizeThreshold（该设置只对Serial和ParNew收集器生效），令大于这个设置值的对象直接在老年代分配
- 长期存活的对象将进入老年代：对象定义了对象年龄计数器。对象在Eden出生并经过一次Minor GC后仍存活，且被Survivor容纳，则被移动到Survivor，且对象年龄设为1。对象在Survivor区熬过一次Minor GC，年龄就加1，当年龄加到一定程度（默认15岁），就会到老年代中。对象晋升老年代的阈值，通过-XX:MaxTenuringThreshold设置
- 动态对象年龄判定：虚拟机并不要求对象年龄达到MaxTenuringThreshold才晋升老年代，如果在Servivor中同年龄所有对象大小总和大于Survivor空间一半，年龄大于等于该年龄的对象可直接进入老年代，无须等到要求年龄
- 空间分配担保：Minor GC前，虚拟机会检查老年代最大可用连续空间是否大于新生代所有对象的总空间。大于则进行Minor GC，小于则看HandlePromotionFailure设置是否允许担保失败（不允许则Full GC）。若允许，则检查老年代最大可用连续空间是否大于历次晋升到老年代对象的平均大小，大于则尝试Minor GC（尝试失败也会触发Full GC），小于则进行Full GC

### 关于JVM内存管理的一些建议

- 手动将生成的无用对象、中间对象置为null，加快内存回收
- 对象池技术。如果生成对象可重用，只是属性不同，可用对象池减少对象生成
- JVM调优。配置JVM参数提高垃圾回收速度，如果没有出现内存泄露且上面办法都不能保证JVM内存回收时，可采用JVM调优解决，不过要经过实体机的长期测试，因为不同参数可能引起不同效果