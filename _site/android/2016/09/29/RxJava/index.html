<!DOCTYPE html>
<html lang="zh-cmn-Hans" prefix="og: http://ogp.me/ns#" class="han-init">
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
    <title>Android 响应式编程框架 RxJava &mdash; Peiqin Lin's Homepage</title>
    <link rel="stylesheet" href="http://localhost:4000/assets/vendor/primer-css/css/primer.css">
    <link rel="stylesheet" href="http://localhost:4000/assets/vendor/primer-markdown/dist/user-content.min.css">
    <link rel="stylesheet" href="http://localhost:4000/assets/vendor/octicons/octicons/octicons.css">
    <link rel="stylesheet" href="http://localhost:4000/assets/css/components/collection.css">
    <link rel="stylesheet" href="http://localhost:4000/assets/css/components/repo-card.css">
    <link rel="stylesheet" href="http://localhost:4000/assets/css/sections/repo-list.css">
    <link rel="stylesheet" href="http://localhost:4000/assets/css/sections/mini-repo-list.css">
    <link rel="stylesheet" href="http://localhost:4000/assets/css/sections/profile.css">
    <link rel="stylesheet" href="http://localhost:4000/assets/css/sections/contact.css">
    <link rel="stylesheet" href="http://localhost:4000/assets/css/sections/news.css">
    <link rel="stylesheet" href="http://localhost:4000/assets/css/components/boxed-group.css">
    <link rel="stylesheet" href="http://localhost:4000/assets/css/globals/common.css">
    <link rel="stylesheet" href="http://localhost:4000/assets/vendor/share.js/dist/css/share.min.css">
    <link rel="stylesheet" href="http://localhost:4000/assets/css/globals/responsive.css">
    <link rel="stylesheet" href="http://localhost:4000/assets/css/posts/index.css">
    <!-- Latest compiled and minified CSS -->
    

    
    <link rel="canonical" href="http://localhost:4000/android/2016/09/29/RxJava/">
    <link rel="alternate" type="application/atom+xml" title="Peiqin Lin's Homepage" href="/feed.xml">
    <link rel="shortcut icon" href="http://localhost:4000/favicon.ico">
    
    <meta property="og:title" content="Android 响应式编程框架 RxJava">
      
    <meta name="keywords" content="Android, RxJava, 开源框架, 响应式编程, 响应式编程框架">
    <meta name="og:keywords" content="Android, RxJava, 开源框架, 响应式编程, 响应式编程框架">
      
    <meta name="description" content="本文的主角RxJava算是Android几个框架里面较为复杂的一个，所以这篇博客花的时间、精力都会比较多。希望读者能通过此文更好的认识和使用RxJava。">
    <meta name="og:description" content="本文的主角RxJava算是Android几个框架里面较为复杂的一个，所以这篇博客花的时间、精力都会比较多。希望读者能通过此文更好的认识和使用RxJava。">
      
    
    
        
    
    <meta property="og:url" content="http://localhost:4000/android/2016/09/29/RxJava/">
    <meta property="og:site_name" content="Peiqin Lin's Homepage">
    <meta property="og:type" content="article">
    <meta property="og:locale" content="zh_CN" />
    
    <meta property="article:published_time" content="2016-09-29">
    
    <script src="http://localhost:4000/assets/vendor/jquery/dist/jquery.min.js"></script>
    <script src="http://localhost:4000/assets/js/jquery-ui.js"></script>
    <script type="text/javascript">
    function toggleMenu() {
        var nav = document.getElementsByClassName("site-header-nav")[0];
        if (nav.style.display == "inline-flex") {
          nav.style.display = "none";
        } else {
          nav.style.display = "inline-flex";
        }
    }
    </script>
	<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script>
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-114643083-1"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
        gtag('config', 'UA-114643083-1');
    </script>
</head>
<body class="" data-mz="">
    <header class="site-header">
        <div class="container">
            <h1><a href="http://localhost:4000/" title="Peiqin Lin's Homepage">Peiqin Lin's Homepage</a></h1>
            <button class="collapsed mobile-visible" type="button" onclick="toggleMenu();">
              <span class="icon-bar"></span>
              <span class="icon-bar"></span>
              <span class="icon-bar"></span>
            </button>
            <nav class="site-header-nav" role="navigation">
                
            </nav>
        </div>
    </header>
    <!-- / header -->

    <section class="collection-head small geopattern" data-pattern-id="Android 响应式编程框架">
<div class="container">
  <div class="columns">
    <div class="column three-fourths">
      <div class="collection-title">
        <h1 class="collection-header">Android 响应式编程框架 RxJava</h1>
        <div class="collection-info">
          
          <span class="meta-info">
            <span class="octicon octicon-calendar"></span> 2016/09/29
          </span>
          
          
          <span class="meta-info">
            <span class="octicon octicon-file-directory"></span>
            <a href="http://localhost:4000/categories/#Android" title="Android">Android</a>
          </span>
          
        </div>
      </div>
    </div>
  </div>
</div>
</section>
<!-- / .banner -->
<section class="container content">
<div class="columns">
  <div class="column three-fourths" >
    <article class="article-content markdown-body">
    <p>本文的主角RxJava算是Android几个框架里面较为复杂的一个，所以这篇博客花的时间、精力都会比较多。希望读者能通过此文更好的认识和使用RxJava。</p>

<p>相关框架源码地址：</p>

<p>RxJava源码地址<a href="https://github.com/ReactiveX/RxJava">https://github.com/ReactiveX/RxJava</a></p>

<p>RxAndroid源码地址：<a href="https://github.com/ReactiveX/RxAndroid">https://github.com/ReactiveX/RxAndroid</a> </p>

<h3 id="概念">概念</h3>

<p>RxJava是什么？相信很多读者一听到这个东西的时候都可能跟我开始的时候一样纳闷，只知道它是个响应式编程的框架，那么具体它到底是什么呢？</p>

<p>有一定Android开发经验的人肯定都知道AsyncTask、Handler等等。这些东西都是为了实现软件的异步操作，而RxJava跟它们的实质作用是差不多的，但是具体来讲，RxJava更加简洁方便！</p>

<p>RxJava作为一个工具库，使用的就是通用形式的观察者模式。这里关于观察者模式并不细讲，但在理解RxJava中对观察者模式的理解很重要，所以有需要的读者可以去查阅一下相关的资料。</p>

<p>在观察者模式中，RxJava的核心组成部分是<code class="language-plaintext highlighter-rouge">Observables</code>和<code class="language-plaintext highlighter-rouge">Subscribers</code>（<code class="language-plaintext highlighter-rouge">Observer</code>是RxJava最小的构建块，实践中使用最多的是<code class="language-plaintext highlighter-rouge">Subscriber</code>）。两者通过<code class="language-plaintext highlighter-rouge">subscribe()</code>方法实现订阅关系。<code class="language-plaintext highlighter-rouge">Observable</code>发送消息，而<code class="language-plaintext highlighter-rouge">Subscriber</code>则用于消费消息。</p>

<h3 id="配置">配置</h3>

<p>添加依赖库：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>compile 'io.reactivex:rxjava:1.2.0'
compile 'io.reactivex:rxandroid:1.2.1'
</code></pre></div></div>

<h3 id="使用">使用</h3>

<h4 id="步骤一创建subscriber">步骤一：创建Subscriber</h4>

<p><code class="language-plaintext highlighter-rouge">Subscriber</code>对<code class="language-plaintext highlighter-rouge">Observer</code>接口进行了一些扩展，基本使用方式是完全一样的：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Subscriber</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">subscriber</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Subscriber</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;()</span> <span class="o">{</span>
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">onNext</span><span class="o">(</span><span class="nc">String</span> <span class="n">s</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">Log</span><span class="o">.</span><span class="na">d</span><span class="o">(</span><span class="n">tag</span><span class="o">,</span> <span class="s">"Item: "</span> <span class="o">+</span> <span class="n">s</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">onCompleted</span><span class="o">()</span> <span class="o">{</span>
        <span class="nc">Log</span><span class="o">.</span><span class="na">d</span><span class="o">(</span><span class="n">tag</span><span class="o">,</span> <span class="s">"Completed!"</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">onError</span><span class="o">(</span><span class="nc">Throwable</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">Log</span><span class="o">.</span><span class="na">d</span><span class="o">(</span><span class="n">tag</span><span class="o">,</span> <span class="s">"Error!"</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">};</span>
</code></pre></div></div>

<p>如果你只想使用基本功能，选择<code class="language-plaintext highlighter-rouge">Observer</code>和<code class="language-plaintext highlighter-rouge">Subscriber</code>是完全一样的。它们的区别对于使用者来说主要有两点：</p>

<ol>
  <li><code class="language-plaintext highlighter-rouge">onStart()</code>：这是<code class="language-plaintext highlighter-rouge">Subscriber</code>增加的方法。它会在事件发送前被调用，用于做准备工作。需要注意的是，如果对准备工作的线程有要求（例如弹出对话框，这必须在主线程执行），<code class="language-plaintext highlighter-rouge">onStart()</code>就不适用了，因为它总是在<code class="language-plaintext highlighter-rouge">subscribe</code>所发生的线程被调用，而不能指定线程。要在指定的线程来做准备工作，可以使用<code class="language-plaintext highlighter-rouge">doOnSubscribe()</code>方法。</li>
  <li><code class="language-plaintext highlighter-rouge">unsubscribe()</code>：这是<code class="language-plaintext highlighter-rouge">Subscriber</code>所实现的另一个接口<code class="language-plaintext highlighter-rouge">Subscription</code>的方法，用于取消订阅。一般在这个方法调用前，可以使用<code class="language-plaintext highlighter-rouge">isUnsubscribed()</code>先判断一下状态。<code class="language-plaintext highlighter-rouge">unsubscribe()</code>很重要，因为在<code class="language-plaintext highlighter-rouge">subscribe()</code>之后，<code class="language-plaintext highlighter-rouge">Observable</code>会持有<code class="language-plaintext highlighter-rouge">Subscriber</code>的引用，将有内存泄露的风险。所以最好保持一个原则：要在不再使用的时候尽快在合适的地方（例如<code class="language-plaintext highlighter-rouge">onPause()</code>、<code class="language-plaintext highlighter-rouge">onStop()</code>等方法中）调用<code class="language-plaintext highlighter-rouge">unsubscribe()</code>来解除引用关系。</li>
</ol>

<h4 id="步骤二创建-observable">步骤二：创建 Observable</h4>

<p><code class="language-plaintext highlighter-rouge">Observable</code>即被观察者，它决定什么时候触发事件以及触发怎样的事件。RxJava使用<code class="language-plaintext highlighter-rouge">create()</code>方法来创建一个 <code class="language-plaintext highlighter-rouge">Observable</code>，并为它定义事件触发规则：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Observable</span> <span class="n">observable</span> <span class="o">=</span> <span class="nc">Observable</span><span class="o">.</span><span class="na">create</span><span class="o">(</span><span class="k">new</span> <span class="nc">Observable</span><span class="o">.</span><span class="na">OnSubscribe</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;()</span> <span class="o">{</span>
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">call</span><span class="o">(</span><span class="nc">Subscriber</span><span class="o">&lt;?</span> <span class="kd">super</span> <span class="nc">String</span><span class="o">&gt;</span> <span class="n">subscriber</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">subscriber</span><span class="o">.</span><span class="na">onNext</span><span class="o">(</span><span class="s">"Hello"</span><span class="o">);</span>
        <span class="n">subscriber</span><span class="o">.</span><span class="na">onNext</span><span class="o">(</span><span class="s">"Hi"</span><span class="o">);</span>
        <span class="n">subscriber</span><span class="o">.</span><span class="na">onNext</span><span class="o">(</span><span class="s">"Aloha"</span><span class="o">);</span>
        <span class="n">subscriber</span><span class="o">.</span><span class="na">onCompleted</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">});</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">create()</code>方法是RxJava最基本的创造事件序列的方法。基于这个方法，RxJava还提供了一些方法用来快捷创建事件队列，例如：</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">just(T...)</code>: 将传入的参数依次发送出来。</li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Observable</span> <span class="n">observable</span> <span class="o">=</span> <span class="nc">Observable</span><span class="o">.</span><span class="na">just</span><span class="o">(</span><span class="s">"Hello"</span><span class="o">,</span> <span class="s">"Hi"</span><span class="o">,</span> <span class="s">"Aloha"</span><span class="o">);</span>
<span class="c1">// 将会依次调用：</span>
<span class="c1">// onNext("Hello");</span>
<span class="c1">// onNext("Hi");</span>
<span class="c1">// onNext("Aloha");</span>
<span class="c1">// onCompleted();</span>
</code></pre></div></div>

<ul>
  <li><code class="language-plaintext highlighter-rouge">from(T[])</code> / <code class="language-plaintext highlighter-rouge">from(Iterable)</code> : 将传入的数组或 <code class="language-plaintext highlighter-rouge">Iterable</code> 拆分成具体对象后，依次发送出来。</li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">String</span><span class="o">[]</span> <span class="n">words</span> <span class="o">=</span> <span class="o">{</span><span class="s">"Hello"</span><span class="o">,</span> <span class="s">"Hi"</span><span class="o">,</span> <span class="s">"Aloha"</span><span class="o">};</span>
<span class="nc">Observable</span> <span class="n">observable</span> <span class="o">=</span> <span class="nc">Observable</span><span class="o">.</span><span class="na">from</span><span class="o">(</span><span class="n">words</span><span class="o">);</span>
<span class="c1">// 将会依次调用：</span>
<span class="c1">// onNext("Hello");</span>
<span class="c1">// onNext("Hi");</span>
<span class="c1">// onNext("Aloha");</span>
<span class="c1">// onCompleted();</span>
</code></pre></div></div>

<p>上面 <code class="language-plaintext highlighter-rouge">just(T...)</code> 的例子和 <code class="language-plaintext highlighter-rouge">from(T[])</code> 的例子，都和之前的 <code class="language-plaintext highlighter-rouge">create(OnSubscribe)</code> 的例子是等价的。</p>

<h4 id="步骤三subscribe-订阅">步骤三：Subscribe (订阅)</h4>

<p>创建了 <code class="language-plaintext highlighter-rouge">Observable</code> 和 <code class="language-plaintext highlighter-rouge">Observer</code> 之后，再用 <code class="language-plaintext highlighter-rouge">subscribe()</code> 方法将它们联结起来，整条链子就可以工作了。代码形式很简单：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">observable</span><span class="o">.</span><span class="na">subscribe</span><span class="o">(</span><span class="n">subscriber</span><span class="o">);</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">Observable.subscribe(Subscriber)</code> 的内部实现是这样的（仅核心代码）：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 注意：这不是 subscribe() 的源码，而是将源码中与性能、兼容性、扩展性有关的代码剔除后的核心代码。</span>
<span class="c1">// 如果需要看源码，可以去 RxJava 的 GitHub 仓库下载。</span>
<span class="kd">public</span> <span class="nc">Subscription</span> <span class="nf">subscribe</span><span class="o">(</span><span class="nc">Subscriber</span> <span class="n">subscriber</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">subscriber</span><span class="o">.</span><span class="na">onStart</span><span class="o">();</span>
    <span class="n">onSubscribe</span><span class="o">.</span><span class="na">call</span><span class="o">(</span><span class="n">subscriber</span><span class="o">);</span>
    <span class="k">return</span> <span class="n">subscriber</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div>

<p>可以看到，<code class="language-plaintext highlighter-rouge">subscriber()</code> 做了3件事：</p>

<ol>
  <li>调用 <code class="language-plaintext highlighter-rouge">Subscriber.onStart()</code> 。这个方法在前面已经介绍过，是一个可选的准备方法。</li>
  <li>调用 <code class="language-plaintext highlighter-rouge">Observable</code> 中的 <code class="language-plaintext highlighter-rouge">OnSubscribe.call(Subscriber)</code> 。在这里，事件发送的逻辑开始运行。从这也可以看出，在 RxJava 中，<code class="language-plaintext highlighter-rouge">Observable</code> 并不是在创建的时候就立即开始发送事件，而是在它被订阅的时候，即当 <code class="language-plaintext highlighter-rouge">subscribe()</code> 方法执行的时候。</li>
  <li>将传入的 <code class="language-plaintext highlighter-rouge">Subscriber</code> 作为 <code class="language-plaintext highlighter-rouge">Subscription</code> 返回。这是为了方便 <code class="language-plaintext highlighter-rouge">unsubscribe()</code>.</li>
</ol>

<p>除了 <code class="language-plaintext highlighter-rouge">subscribe(Observer)</code> 和 <code class="language-plaintext highlighter-rouge">subscribe(Subscriber)</code> ，<code class="language-plaintext highlighter-rouge">subscribe()</code> 还支持不完整定义的回调，RxJava 会自动根据定义创建出<code class="language-plaintext highlighter-rouge">Subscriber</code> 。形式如下：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Action1</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">onNextAction</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Action1</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;()</span> <span class="o">{</span>
    <span class="c1">// onNext()</span>
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">call</span><span class="o">(</span><span class="nc">String</span> <span class="n">s</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">Log</span><span class="o">.</span><span class="na">d</span><span class="o">(</span><span class="n">tag</span><span class="o">,</span> <span class="n">s</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">};</span>
<span class="nc">Action1</span><span class="o">&lt;</span><span class="nc">Throwable</span><span class="o">&gt;</span> <span class="n">onErrorAction</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Action1</span><span class="o">&lt;</span><span class="nc">Throwable</span><span class="o">&gt;()</span> <span class="o">{</span>
    <span class="c1">// onError()</span>
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">call</span><span class="o">(</span><span class="nc">Throwable</span> <span class="n">throwable</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Error handling</span>
    <span class="o">}</span>
<span class="o">};</span>
<span class="nc">Action0</span> <span class="n">onCompletedAction</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Action0</span><span class="o">()</span> <span class="o">{</span>
    <span class="c1">// onCompleted()</span>
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">call</span><span class="o">()</span> <span class="o">{</span>
        <span class="nc">Log</span><span class="o">.</span><span class="na">d</span><span class="o">(</span><span class="n">tag</span><span class="o">,</span> <span class="s">"completed"</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">};</span>

<span class="c1">// 自动创建 Subscriber ，并使用 onNextAction 来定义 onNext()</span>
<span class="n">observable</span><span class="o">.</span><span class="na">subscribe</span><span class="o">(</span><span class="n">onNextAction</span><span class="o">);</span>
<span class="c1">// 自动创建 Subscriber ，并使用 onNextAction 和 onErrorAction 来定义 onNext() 和 onError()</span>
<span class="n">observable</span><span class="o">.</span><span class="na">subscribe</span><span class="o">(</span><span class="n">onNextAction</span><span class="o">,</span> <span class="n">onErrorAction</span><span class="o">);</span>
<span class="c1">// 自动创建 Subscriber ，并使用 onNextAction、 onErrorAction 和 onCompletedAction 来定义 onNext()、 onError() 和 onCompleted()</span>
<span class="n">observable</span><span class="o">.</span><span class="na">subscribe</span><span class="o">(</span><span class="n">onNextAction</span><span class="o">,</span> <span class="n">onErrorAction</span><span class="o">,</span> <span class="n">onCompletedAction</span><span class="o">);</span>
</code></pre></div></div>

<h4 id="步骤四操作符">步骤四：操作符</h4>

<p>如果你只是想了解基础的部分，那以上的内容可以帮你解决了。不过如果真正要用到开发中，我们还需要了解很多东西，比如RxJava操作符。</p>

<p>操作符就是为了解决对Observable对象的变换的问题，操作符用于在Observable和最终的Subscriber之间修改Observable发出的事件。RxJava提供了很多很有用的操作符。比如map操作符，就是用来把把一个事件转换为另一个事件的。在这里给大家推荐一个学习操作符比较好的地方<a href="https://mcxiaoke.gitbooks.io/rxdocs/content/Operators.html">Operaters</a>。当然，如果你直接点进去这个网站，你可能会一头雾水。那么，就让我们用一个例子来讲解一下。</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 得到多个Student对象中的name，保存到nameList中</span>
<span class="nc">Observable</span><span class="o">.</span><span class="na">just</span><span class="o">(</span><span class="n">student1</span><span class="o">,</span> <span class="n">student2</span><span class="o">,</span> <span class="n">student2</span><span class="o">)</span>
                <span class="c1">//使用map进行转换，参数1：转换前的类型，参数2：转换后的类型</span>
                <span class="o">.</span><span class="na">map</span><span class="o">(</span><span class="k">new</span> <span class="nc">Func1</span><span class="o">&lt;</span><span class="nc">Student</span><span class="o">,</span> <span class="nc">String</span><span class="o">&gt;()</span> <span class="o">{</span>
                    <span class="nd">@Override</span>
                    <span class="kd">public</span> <span class="nc">String</span> <span class="nf">call</span><span class="o">(</span><span class="nc">Student</span> <span class="n">i</span><span class="o">)</span> <span class="o">{</span>
                        <span class="nc">String</span> <span class="n">name</span> <span class="o">=</span> <span class="n">i</span><span class="o">.</span><span class="na">getName</span><span class="o">();</span><span class="c1">//获取Student对象中的name</span>
                        <span class="k">return</span> <span class="n">name</span><span class="o">;</span><span class="c1">//返回name</span>
                    <span class="o">}</span>
                <span class="o">})</span>
                <span class="o">.</span><span class="na">subscribe</span><span class="o">(</span><span class="k">new</span> <span class="nc">Action1</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;()</span> <span class="o">{</span>
                    <span class="nd">@Override</span>
                    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">call</span><span class="o">(</span><span class="nc">String</span> <span class="n">s</span><span class="o">)</span> <span class="o">{</span>
                        <span class="n">nameList</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">s</span><span class="o">);</span>
                    <span class="o">}</span>
                <span class="o">});</span>
</code></pre></div></div>

<p>此外，flatMap也是经常用到的一个操作符，它的使用和理解相对复杂一些：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">List</span><span class="o">&lt;</span><span class="nc">Student</span><span class="o">&gt;</span> <span class="n">students</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;</span><span class="nc">Student</span><span class="o">&gt;();</span>
        <span class="n">students</span><span class="o">.</span><span class="na">add</span><span class="o">...</span>
        <span class="o">...</span>

        <span class="nc">Observable</span><span class="o">.</span><span class="na">from</span><span class="o">(</span><span class="n">students</span><span class="o">)</span>
                <span class="o">.</span><span class="na">flatMap</span><span class="o">(</span><span class="k">new</span> <span class="nc">Func1</span><span class="o">&lt;</span><span class="nc">Student</span><span class="o">,</span> <span class="nc">Observable</span><span class="o">&lt;</span><span class="nc">Course</span><span class="o">&gt;&gt;()</span> <span class="o">{</span>
                    <span class="nd">@Override</span>
                    <span class="kd">public</span> <span class="nc">Observable</span><span class="o">&lt;</span><span class="nc">Course</span><span class="o">&gt;</span> <span class="nf">call</span><span class="o">(</span><span class="nc">Student</span> <span class="n">student</span><span class="o">)</span> <span class="o">{</span>
                        <span class="k">return</span> <span class="nc">Observable</span><span class="o">.</span><span class="na">from</span><span class="o">(</span><span class="n">student</span><span class="o">.</span><span class="na">getCoursesList</span><span class="o">());</span>
                    <span class="o">}</span>
                <span class="o">})</span>
                <span class="o">.</span><span class="na">subscribe</span><span class="o">(</span><span class="k">new</span> <span class="nc">Action1</span><span class="o">&lt;</span><span class="nc">Course</span><span class="o">&gt;()</span> <span class="o">{</span>
                    <span class="nd">@Override</span>
                    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">call</span><span class="o">(</span><span class="nc">Course</span> <span class="n">course</span><span class="o">)</span> <span class="o">{</span>
                        <span class="nc">Log</span><span class="o">.</span><span class="na">i</span><span class="o">(</span><span class="no">TAG</span><span class="o">,</span> <span class="n">course</span><span class="o">.</span><span class="na">getName</span><span class="o">());</span>
                    <span class="o">}</span>
                <span class="o">});</span>
</code></pre></div></div>

<p>常见的操作符还有</p>

<ul>
  <li>filter：集合进行过滤</li>
  <li>each：遍历集合</li>
  <li>take：取出集合中的前几个</li>
  <li>skip：跳过前几个元素</li>
  <li>unique：相当于按照数学上的集合处理，去重</li>
</ul>

<h4 id="步骤五线程操作">步骤五：线程操作</h4>

<p>事件的发起和消费默认都是在同一个线程中执行，也就是说之前我们使用的RxJava是同步的。使用RxJava，你可以使用<code class="language-plaintext highlighter-rouge">subscribeOn()</code>指定观察者代码运行的线程，使用<code class="language-plaintext highlighter-rouge">observerOn()</code>指定订阅者运行的线程。代码如下：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">myObservableServices</span><span class="o">.</span><span class="na">retrieveImage</span><span class="o">(</span><span class="n">url</span><span class="o">)</span>
    <span class="o">.</span><span class="na">subscribeOn</span><span class="o">(</span><span class="nc">Schedulers</span><span class="o">.</span><span class="na">io</span><span class="o">())</span>
    <span class="o">.</span><span class="na">observeOn</span><span class="o">(</span><span class="nc">AndroidSchedulers</span><span class="o">.</span><span class="na">mainThread</span><span class="o">())</span>
    <span class="o">.</span><span class="na">subscribe</span><span class="o">(</span><span class="n">bitmap</span> <span class="o">-&gt;</span> <span class="n">myImageView</span><span class="o">.</span><span class="na">setImageBitmap</span><span class="o">(</span><span class="n">bitmap</span><span class="o">));</span>
</code></pre></div></div>

<p>调度器Schedulers实际上有很多种，具体如下：</p>

<ul>
  <li>Schedulers.computation( )：用于计算任务，如事件循环或和回调处理，不要用于IO操作(IO操作请使用Schedulers.io())；默认线程数等于处理器的数量</li>
  <li>Schedulers.from(executor)：使用指定的Executor作为调度器</li>
  <li>Schedulers.immediate( )：在当前线程立即开始执行任务</li>
  <li>Schedulers.io( )：用于IO密集型任务，如异步阻塞IO操作，这个调度器的线程池会根据需要增长；对于普通的计算任务，请使用Schedulers.computation()；Schedulers.io( )默认是一个CachedThreadScheduler，很像一个有线程缓存的新线程调度器</li>
  <li>Schedulers.newThread( )：为每个任务创建一个新线程</li>
  <li>Schedulers.trampoline( )：当其它排队的任务完成后，在当前线程排队开始执行</li>
</ul>

<h4 id="步骤六subscriptions">步骤六：Subscriptions</h4>

<p>当调用Observable.subscribe()，会返回一个Subscription对象。这个对象代表了被观察者和订阅者之间的联系。</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ubscription subscription = Observable.just("Hello, World!")
    .subscribe(s -&gt; System.out.println(s));1212
</code></pre></div></div>

<p>你可以在后面使用这个Subscription对象来操作被观察者和订阅者之间的联系.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>subscription.unsubscribe();
System.out.println("Unsubscribed=" + subscription.isUnsubscribed());
// Outputs "Unsubscribed=true"
</code></pre></div></div>

<h4 id="步骤七android生命周期">步骤七：Android生命周期</h4>

<p>如何处理Activity的生命周期？主要就是两个问题： </p>

<ol>
  <li>
    <p>在configuration改变（比如转屏）之后继续之前的Subscription</p>

    <p>解决方案是使用RxJava的缓存机制，这样就可以对同个<code class="language-plaintext highlighter-rouge">Observable</code>对象执行<code class="language-plaintext highlighter-rouge">unsubscribe</code>或<code class="language-plaintext highlighter-rouge">resubscribe</code>，却不用重复运行得到<code class="language-plaintext highlighter-rouge">Observable</code>的代码。<code class="language-plaintext highlighter-rouge">cache()</code>或<code class="language-plaintext highlighter-rouge">replay()</code>会继续执行网络请求（甚至你调用了<code class="language-plaintext highlighter-rouge">unsubscribe</code>也不会停止）。这就是说你可以在Activity重新创建的时候从<code class="language-plaintext highlighter-rouge">cache()</code>的返回值中创建一个新的<code class="language-plaintext highlighter-rouge">Observable</code>对象。</p>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Observable&lt;Photo&gt; request = service.getUserPhoto(id).cache();
Subscription sub = request.subscribe(photo -&gt; handleUserPhoto(photo));

// ...When the Activity is being recreated...
sub.unsubscribe();

// ...Once the Activity is recreated...
request.subscribe(photo -&gt; handleUserPhoto(photo));
</code></pre></div>    </div>

    <p>注意，两次sub是使用的同一个缓存的请求。当然在哪里去存储请求的结果还是要自己做，必须在生命周期外的某个地方存储（retained fragment或者单例等等）。</p>
  </li>
  <li>
    <p>Observable持有Context导致的内存泄露</p>

    <p>解决方案就是在生命周期的某个时刻取消订阅。一个很常见的模式就是使用<code class="language-plaintext highlighter-rouge">CompositeSubscription</code>来持有所有的<code class="language-plaintext highlighter-rouge">Subscriptions</code>，然后在<code class="language-plaintext highlighter-rouge">onDestroy()</code>或者<code class="language-plaintext highlighter-rouge">onDestroyView()</code>里取消所有的订阅。</p>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>private CompositeSubscription mCompositeSubscription
    = new CompositeSubscription();

private void doSomething() {
    mCompositeSubscription.add(
        AndroidObservable.bindActivity(this, Observable.just("Hello, World!"))
        .subscribe(s -&gt; System.out.println(s)));
}

@Override
protected void onDestroy() {
    super.onDestroy();

    mCompositeSubscription.unsubscribe();
}
</code></pre></div>    </div>

    <p>你可以在Activity/Fragment的基类里创建一个<code class="language-plaintext highlighter-rouge">CompositeSubscription</code>对象，在子类中使用它。</p>

    <p>注意：一旦你调用了<code class="language-plaintext highlighter-rouge">CompositeSubscription.unsubscribe()</code>，这个<code class="language-plaintext highlighter-rouge">CompositeSubscription</code>对象就不可用了, 如果你还想使用<code class="language-plaintext highlighter-rouge">CompositeSubscription</code>，就必须在创建一个新的对象了。</p>
  </li>
</ol>

<p>RxJava虽然写成博客后看起来很深奥很复杂，但只要掌握了它，你会在Android很多开发场景中感受到它的方便。</p>

    </article>
    <div class="share">
      <div class="share-component"></div>
    </div>
    <div class="comment">
      
  
        <div id="container"></div>
        <link rel="stylesheet" href="https://imsun.github.io/gitment/style/default.css">
        <script src="https://imsun.github.io/gitment/dist/gitment.browser.js"></script>
        <script>
        var gitment = new Gitment({
            id: '/android/2016/09/29/RxJava/',
            owner: 'lpq29743',
            repo: 'blog-comments',
            oauth: {
                client_id: '5818ceff784afe05d31c',
                client_secret: 'dc7e8efc044c7194cf453740f82c646aa998f206',
            },
        })
        gitment.render('container')
        </script>
  


    </div>
	<ul class="pager">
		
		<li class="previous">
			<a href="/android/2016/09/28/ORMLite/" data-toggle="tooltip" data-placement="top" title="Android ORM 框架 ORMLite">
				Previous<br>
				<span>Android ORM 框架 ORMLite</span>
			</a>
		</li>
		
		
		<li class="next">
			<a href="/android/2016/10/04/AndroidStyle/" data-toggle="tooltip" data-placement="top" title="Android style 笔记">
				Next<br>
				<span>Android style 笔记</span>
			</a>
		</li>
		
	</ul>
  </div>
  <div class="column one-fourth">
    
<h3>Search</h3>
<div id="site_search">
    <input type="text" id="search_box" placeholder="Search">
</div>

<ul id="search_results"></ul>

<link rel="stylesheet" type="text/css" href="http://localhost:4000/assets/css/modules/sidebar-search.css">
<script src="http://localhost:4000/assets/js/jekyll-search.min.js"></script>
<script src="http://localhost:4000/assets/js/search.js"></script>

<script type="text/javascript">
SimpleJekyllSearch({
    searchInput: document.getElementById('search_box'),
    resultsContainer: document.getElementById('search_results'),
    json: 'http://localhost:4000/assets/search_data.json',
    searchResultTemplate: '<li><a href="{url}" title="{desc}">{title}</a></li>',
    noResultsText: 'No results found',
    limit: 10,
    fuzzy: false,
    exclude: ['Welcome']
})
</script>

    
<h3 class="post-directory-title mobile-hidden">Table of Contents</h3>
<div id="post-directory-module" class="mobile-hidden">
  <section class="post-directory">
  <!-- Links that trigger the jumping -->
  <!-- Added by javascript below -->
  <dl></dl>
  </section>
</div>

<script src="http://localhost:4000/assets/js/jquery.toc.js"></script>

  </div>
</div>
</section>
<!-- /section.content -->

    <footer class="container">
        <div class="site-footer" role="contentinfo">
            <div class="copyright left mobile-block">
                <a href="javascript:window.scrollTo(0,0)" class="right mobile-visible">TOP</a>
            </div>

            <ul class="site-footer-links right mobile-hidden">
                <li>
                    <a href="javascript:window.scrollTo(0,0)" >TOP</a>
                </li>
            </ul>
            <a href="https://github.com/lpq29743/lpq29743.github.io" target="_blank" aria-label="view source code">
                <span class="mega-octicon octicon-mark-github" title="GitHub"></span>
            </a>
            <ul class="site-footer-links mobile-hidden">
                
            </ul>

        </div>
    </footer>
    <!-- / footer -->
    <script src="http://localhost:4000/assets/vendor/share.js/dist/js/share.min.js"></script>
    <script src="http://localhost:4000/assets/js/geopattern.js"></script>
    <script src="http://localhost:4000/assets/js/prism.js"></script>
    <link rel="stylesheet" href="http://localhost:4000/assets/css/globals/prism.css">
    <script>
      jQuery(document).ready(function($) {
        // geopattern
        $('.geopattern').each(function(){
          $(this).geopattern($(this).data('pattern-id'));
        });
       // hljs.initHighlightingOnLoad();
      });
    </script>
    
</body>
</html>
